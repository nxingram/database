# SQL
### Structured Query Language, è il linguaggio che permette di effettuare le operazioni per estrarre e manipolare i dati da un database.

E’ lo standard tra i sistemi relazionali: viene usato in tutti i prodotti DBMS come set di comandi per l’utente della base di
dati

Tipi di istruzioni SQL
- DCL (Data control language): permette di gestire il controllo degli accessi e i permessi per gli utenti

- DDL (Data Definition Language): permette di definire la struttura del database

- DML (Data manipulation language): permette di modificare i dati contenuti nel db, con le operazioni di inserimento, variazione e cancellazione

- TCL (Transaction Control Language): queste operazioni gestiscono le transazioni nel database

- Query Language: permette di porre interrogazioni al db

### DCL
gestire il controllo degli accessi e i permessi per gli utenti:

    CREATE USER 'nomeutente'@'host' IDENTIFIED BY 'password';


    GRANT ALL 
        ON nomedb.* 
        TO 'nomeutente'@'host';

### DDL
permette di definire la struttura del database

    CREATE DATABASE databaseName; --crea un nuovo database
    DROP DATABASE databaseName; --cancella il database
    CREATE TABLE tableName(…); --crea una nuova tabella nel DB
    ALTER TABLE tableName … ; --modifica la struttura di una tabella
    DROP TABLE tableName … ; --cancella una tabella dal DB
    CREATE INDEX indexName … ; --crea un indice su una certa tabella
    ALTER TABLE tableName DROP INDEX indexName … ; --elimina l’indice specificato

### DML
permette di modificare i dati contenuti nel db, con le operazioni di inserimento, variazione e cancellazione

    Inserimento:

    INSERT INTO tableName(field1, field2, …)
        VALUES ('value1', 'value2', '…');

    Cancellazione:
    
    DELETE FROM tableName 
        WHERE column_name = some_value;<br>

    Aggiornamento:

    UPDATE tableName
        SET column_name = new_value
        WHERE column_name = some_value;

### TCL
gestiscono le transazioni nel database

    COMMIT; --rende definitive le operazioni sul database
    ROLLBACK; --ripristina i dati eliminando le modifiche temporanee
    SAVEPOINT save_point_name(…); --crea un punto di salvataggio

Query Language<br>
permette di porre interrogazioni al db

    SELECT field(s)
    FROM table(s)
    WHERE condition(s);
- Attraverso SELECT vengono selezionati dei campi (attributi) da una o più tabelle e
restituiti all'utente sotto forma di una "nuova tabella" (resultset)

- Attraverso la clausola WHERE è possibile filtrare il resultset sulla base di alcune
regole

<br>


## Query language
### lista comandi:
    #login root
    mysql -u root -p
    #psw root

    #crea database, user and assign privileges
    create database if not exists nomedatabase;

    # nuovo utente
    create user 'username'@'localhost' identified by 'password';

    # permessi
    grant ALL on nomedatabase.* to 'username'@'localhost'; 

    # uscire e rientrare con nuovo utente
    exit;

    # login
    mysql -u username -p
    #inserire psw

    # selezionare database
    use nomedatabase;

    ## db selezionato
    show database(); 

    # tabelle
    show table;
    describe table;
    desc table;
    desc autore; desc editore; ...
    show columns from studente;
    ## N.B.!!
    show create table studente\G;
    desc studente\G;

    #-------------------------------
    ## Table Status
    show table status like 'studente'\G;

    #-------------------------------
    ## warnings
    show warnings;

    #-------------------------------
    ## Load from File
    # trascinare file in terminale x copiare il path
    source c:\path\file.sql  ->> senza ";"!

    #-------------------------------
    ## alter table
    ALTER TABLE studente rename to studente2;
    rename table studente2 to studente;

    alter table studente modify nome varchar(30) not null;
    alter table studente modify cognome varchar(50) not null;
    alter table studente modify provincia char(2) default 'To';
    alter table studente modify regione varchar(20) default 'Piemonte';

    alter table studente change data_nascita data_di_nascita date;

    alter table studente add eta tinyint;
    alter table studente modify eta tinyint first;
    alter table studente modify eta tinyint after email;
    alter table studente drop eta;

    #-------------------------------
    ## INDEX
    # k_cogn = nome indice 
    # (k = key)
    alter table studente add index k_cogn(cognome);

    #-------------------------------
    ## INSERT
    insert into studente(nome, cognome, email) value('Paolo', 'Bianchi','pb@gmail.com'); # VALUES per righe multiple

    insert into studente(nome, cognome, email) 
        value('Paola', 'Rossi','pr@gmail.com'), ('Marco', 'Verdi', 'mv@gamil.com');
        
    #campo provincia e regione, se scrivo valore default (non stringa) -> mette il valore di default, come se non mettessi il campo

    #alternativa
    insert into studente set nome='carlo', cognome='magno', email='magnoc@email.it';

    #valori default espliciti
    insert into studente
    (nome,cognome,genere,indirizzo,citta,provincia,regione,email,data_nascita)
    values('alda','deusanio','f','via pergola 15','settimo',default,default,'aldesa@gmail.com','2051-10-13');

    create table if not exists amico(
        id int auto_increment primary key,
        nome varchar(40),
        cognome varchar(50)
    );

    insert into amico(nome, cognome) select nome, cognome from studente;

    create table if not exists parente(
        id int auto_increment primary key,
        nome varchar(40),
        cognome varchar(50)
    ) select nome,cognome from amico;

    #-------------------------------
    ## selezione dei dati 
    select * from studente;

    #-------------------------------
    ## UPDATE
    update studente set genere='M', indirizzo='Via Roma 5', citta='Torino' where id=1;

    #-------------------------------
    ## Data
    update studente set data_nascita='2001-04-27' where id=1
    show warnings;

    #-------------------------------
    ## sql mode
    select @@sql_mode;
    set sql_mode='traditional';
    update studente set data_nascita='27-04-2001' where id=1; -> ERRORE FORMATO DATA

    set sql_mode='NO_ZERO_IN_DATE,NO_ZERO_DATE,NO_ENGINE_SUBSTITUTION';
    update studente set data_nascita='27-04-2001' where id=1; -> WARNING DATA TRONCATA  0000-00-00


    #-------------------------------
    ## DELETE
    insert into studente(nome, cognome, email) value('test', 'delete','td@gmail.com');
    delete from studente where id=4;

    delete from studente; -> CANCELLA TUTTO

    #-------------------------------
    ## TRUNCATE
    ##cancella la tabella e la ricrea ->> resetta autoincrement
    truncate table studente #->> CANCELLA TUTTO SUPERVELOCE

    #-------------------------------
    ## INSERT INTO ... SELECT
    #varchar devono avere stesse dimensioni
    create table if not exists amico(
        nome varchar(30),
        cognome varchar(50)
    );

    INSERT INTO amico(nome, cognome) SELECT nome, cognome from studente;

    #-------------------------------
    ## create table...select
    CREATE TABLE IF NOT EXISTS parente(
        nome varchar(30),
        cognome varchar(50)
    ) select nome, cognome from studente;

    #-------------------------------
    ## duplicare tabella ->> copy table
    create table studente2 like studente; ->> vuota
    insert into studente2 select * from studente;

    #-------------------------------
    #comando unico MA NON viene copiata tutta la struttura,
    #mancano chiavi e indici
    create table studente3 as select * from studente; 
    drop table studente3;

    #-------------------------------
    ## TABLE STATUS
    show table status like 'studente3'\G 

    #-------------------------------
    ## impostare auto_increment
    alter table studente2 auto_increment=1

    #-------------------------------
    ## show columns == DESC studente
    show columns from studente; desc studente;


    #-------------------------------
    ## commenti
    CREATE TABLE if not exists commento(
        id int auto_increment,
        nome varchar(30) comment "questo e' il nome",
        cognome varchar(50) comment "questo e' il cognome",
        primary key(id)
    ) comment 'tabella commenti';

    show full columns from commento;

    #-------------------------------
    ## ORDER BY ASC/DESC campi multipli
    select cognome,nome,email from studente where genere='f' order by cognome desc, nome asc;

    #-------------------------------
    ## limit indice, quantità
    # indice ->> a partire dal numero 5 (quinta tupla della tabella)
    select * from studente limit 5, 3;

    # tabella con 20 record
    # 10,10 ->> mostra i secondi 10

    #-------------------------------
    ## >=
    select cognome,nome, data_nascita from studente where data_nascita>='1990-01-01' order by data_nascita; 

    #-------------------------------
    ## AND - OR 
    select * from studente where genere='m' or provincia ='to'; 

    #-------------------------------
    ## IN - NOT IN ->> elenco
    select * from studente where provincia in ('al', 'cn');

    #-------------------------------
    ## BETWEEN
    select * from studente where data_nascita between '1980-01-01' and '1990-01-01';

    #-------------------------------
    ## NULL VALUES
    insert into studente(nome.cognome.email) value('Andrea','Gullo','andygull@gmail.com');
    select * from where studente genere is not null;

    #-------------------------------
    ## LIKE, NOT LIKE
    # wildcard
    # % ->> 0+
    # _ ->> 1
    select nome from studente where nome like '%o';

    #-------------------------------
    ## Addizione e Sottrazione
    select 5 + 4;

    #-------------------------------
    ## Unire 2 o + Tabelle 
    # con alias
    # where == inner join
    # (inner joi == join)
    select libro.titolo, editore.nome from libro,editore where libro.editore_id=editore.id;

    select libro.titolo, autore.nome from autore,libro,autore_libro where libro_id=libro.id and autore_id=autore.id;

    select titolo, pagine, prezzo, a.nome as 'aut_nome', a.cognome as 'aut_cogn', e.nome as 'editore'
    from libro as l ,autore as a ,editore as e ,autore_libro as al  
    where al.libro_id=l.id 
    and al.autore_id=a.id 
    and e.id=l.editore_id;


    #-------------------------------
    ## AS ->> è facoltativo
    select titolo, pagine, prezzo, a.nome aut_nome, a.cognome  aut_cogn, e.nome editore
    from libro  l ,autore  a ,editore  e ,autore_libro  al  
    where al.libro_id=l.id 
    and al.autore_id=a.id 
    and e.id=l.editore_id;

    #-------------------------------
    ## Operatori
    select titolo, prezzo, prezzo*1.10 'prezzo con iva' from libro;

    alter table libro  add p_iva decimal(6,2) after prezzo; 
    update libro set p_iva=10.00;
    update libro set p_iva=prezzo*1.1; ->> warning data truncated, sui decimali

    insert into libro(titolo, prezzo, p_iva, pagine, editore_id) values('La Divina Commedia',10.50,prezzo*1.1,154,2);

    #-------------------------------
    ### Funzioni

    ## AVG
    select AVG(prezzo) media_prezzo from libro;

    #-------------------------------
    ## COUNT
    select COUNT(*) from libro; ->> conta le righe
    select COUNT(pagine) from libro; ->> solo valori NOT NULL 

    select count(*) from studente where genere='f';
    select count(provincia) from studente where provincia='to';
    select count(*) from studente where genere is null;

    #-------------------------------
    ## MAX, MIN
    select max(prezzo) 'il + caro', min(prezzo) 'il - caro' from libro;

    ## SUM
    select sum(prezzo) 'valore catalogo' from libro;
    select sum(prezzo) 'valore catalogo' from libro where pagine >= 100;

    #-------------------------------
    ## FLOOR, CEILING 
    select prezzo, floor(prezzo) , ceiling(prezzo) from libro;

    #-------------------------------
    ## ROUND
    select prezzo, round(prezzo,1) from libro;
    select prezzo, round(prezzo) from libro;

    #-------------------------------
    ## Nidificazione funzioni
    select round(avg(prezzo),2) from libro;

    #-------------------------------
    ## UCASE, LCASE
    select ucase(cognome), lcase(nome) from studente where genere = 'f'; 

    #-------------------------------
    ## LENGTH
    select nome, LENGTH(nome),  cognome, LENGTH(cognome) from studente;
    select max(LENGTH(nome)), min(LENGTH(cognome)) from studente;

    #-------------------------------
    ## CONCAT, CONCAT_WS
    select concat(nome, ' ', cognome) from studente where genere = 'f';
    select CONCAT_WS(' ', nome, cognome, citta, provincia) from studente;

    #-------------------------------
    ## SUBSTRING(str,pos,len) , SUBSTRING(str from pos for len)
    select nome, substring(nome,1,3) from studente;
    select nome, substring(nome,2) from studente; ->> len opt - coda della stringa
    select substring('stringa',1,3);

    #-------------------------------
    ## LEFT, RIGHT
    select left('oscar',2), right('oscar',2);

    #-------------------------------
    ## funzioni combinate
    select ucase(CONCAT_WS('.',left(nome,1),cognome)) from studente;


    #-------------------------------
    ## REPLACE
    update studente set email = replace(email, 'gmail.com', 'gmail.it') where genere = 'f'; ->> solo gmail

    #-------------------------------
    ## funzioni Data e Ora 
    ## NOW, YEAR, MONTH, DAY
    ## HOUR, MINUTE, SECOND
    ## CUDATE, CURTIME
    ## DAYOFWEEK, DAYOFYEAR, DAYNAME, MONTHNAME
    select now();
    select curdate(), curtime();
    select monthname('2020-01-01'); ->> january
    select monthname('2020-06-01'), dayofyear('2020-06-01'), dayname('2020-06-01');

    select year(curdate());
    select data_nascita, year(data_nascita) from studente;
    select data_nascita, dayofyear(data_nascita) from studente;
    select data_nascita, dayname(data_nascita) from studente;

    select hour(now());
    select hour(curtime());
    select dayofweek(curdate()), dayofyear(curdate());

    #-------------------------------
    ## LOCALE
    select @@LC_TIME_NAMES; ->> en_US  (@@ seleziona variabili globali)
    set LC_TIME_NAMES='it_IT';

    #-------------------------------
    ## DATE_FORMAT, TIME_FORMAT
    ## STR_TO_DATE, UNIX_TIMESTAMP
    ## metacaratteri:  %d, %m, %y, %H, %i, %s, %p ->> i = minuti, p = am/pm, %h = ore am/pm
    select DATE_FORMAT(curdate(), '%d-%m-%Y');
    select DATE_FORMAT(curdate(), '%D-%M-%Y');

    select data_nascita, DATE_FORMAT(data_nascita, '%d-%m-%Y') 'data nascita' from studente; 
    select time_format(curtime(), '%h:%i:%s %p');

    #-------------------------------
    ## STR_TO_DATE(str, format)
    select str_to_date('01-02-2021', '%d-%m-%Y');

    insert into studente(nome,cognome,email,data_nascita) 
    values('franco','allegri','frall@gmail.com', STR_TO_DATE('05/10/1969','%d/%m/%Y'));

    select str_to_date(concat_ws('/','05','10','1969'), '%d/%m/%Y');

    #-------------------------------
    ## ADDDATE, ADDTIME
    select adddate(curdate(), 5);
    select adddate(curdate(), interval 5 month);
    select adddate(curdate(), interval 5 year);

    select addtime(curtime(),'05:05:05');

    #-------------------------------
    ## DATEDIFF ->> scadenza fattura
    select DATEDIFF('2021-2-28', curdate());
    select DATEDIFF('2021-2-28', '2021-01-28');

    #-------------------------------
    ## TIMESTAMPADD(unità, intervallo, espr_datetime) 
    select curtime(), timestampadd(minute, 3, curtime());
    select curtime(), timestampadd(year, 3, curtime());

    #-------------------------------
    ## TIMESTAMPDIFF ->> Calcolo Età  
    ## TIMESTAMPDIFF(unità, intervallo, espr_datetime)
    select nome, cognome, data_nascita, timestampdiff(year, data_nascita, curdate()) eta 
    from studente order by eta asc;

    select nome, cognome, genere, timestampdiff(year, data_nascita, curdate()) eta 
    from studente where genere is not null and data_nascita is not null order by eta asc;

    alter table studente add eta tinyint after data_nascita;
    update studente set eta = timestampdiff(year, data_nascita, curdate()) where data_nascita is not null;

    #------------------------------
    ## formattare numeri: FORMAT(num, decimali, LOCALE)
    select avg(prezzo*1000000) from libro;
    select format(prezzo*1000000, 2, 'de_DE') from libro; ->> non esiste per it_IT :(


    #-------------------------------
    ## Raggruppamenti

    ## DISTINCT
    select DISTINCT cognome from studente; 
    select DISTINCT cognome from studente where cognome like 'v%' order by cognome; 

    #-------------------------------
    ## GROUP BY 
    select cognome from studente group by cognome order by cognome;

    select genere, count(genere) from studente group by genere;

    #->> perdo 2 record editore xè editore_id non è presente in libro
    select e.nome, count(e.nome)
    from libro l, editore e  
    where l.editore_id=e.id
    group by e.nome 
    order by e.nome asc;

    # età media studenti divisi x genere
    select genere, AVG(timestampdiff(YEAR, data_nascita, curdate())) 'eta media' 
    from studente
    group by genere;

    # media prezzo x editore
    select e.nome, round(avg(l.prezzo),2) 'prezzo medio' 
    from libro l, editore e 
    where l.editore_id=e.id 
    group by e.nome;

    #-------------------------------
    ## Group by + HAVING
    select cognome, count(*) quanti 
    from studente 
    group by cognome HAVING quanti > 1
    order by quanti desc;

    # studenti raggrupati x genere e provincia
    # * ->> conta i record
    select provincia, genere, count(*) tot 
    from studente 
    group by genere, provincia having tot > 1
    order by provincia;

    #-------------------------------
    ## Ordine Filtri
    select 
    from 
    where 
    group by ... having
    order by ;

    select provincia, genere, count(cognome) numero 
    from studente
    where provincia = 'to'
    group by genere having genere is not null;


    #-------------------------------
    ## UNION [DISTINCT | ALL]
    # condizione ->> numero colonne e data type deve essere uguale
    # stesso tipo di dato o dato convertibile

    select stato,capitale from europa 
    UNION 
    select stato,capitale from africa 
    UNION 
    select stato,capitale from america
    order by stato; 

    # ->> distinct implicito ->> rimuove le ripetizioni
    select nome, cognome from parente
    union 
    select nome, cognome from studente
    ;

    # UNION ALL
    select nome, cognome from parente
    union ALL
    select nome, cognome from studente
    ;


    #-------------------------------
    ## EQUIJOIN O JOIN Semplice
    # ->> where ...
    select l.id, l.titolo, editore_id, e.id, e.nome  
    from libro l, editore e 
    where l.editore_id = e.id; 

    #-------------------------------
    ## INNER JOIN
    # -->> uguale a where!
    select l.id, l.titolo, l.editore_id, e.id, e.nome 
    from libro l
    INNER JOIN editore e ON  l.editore_id = e.id;

    #-------------------------------
    ## JOIN (inner) 
    select l.id, l.titolo, concat_ws(' ',a.nome,a.cognome) autore, e.nome
    from libro l
    JOIN autore_libro al ON  l.id = al.libro_id
    JOIN autore a ON a.id=al.autore_id
    join editore e ON l.editore_id=e.id;


    ## LEFT JOIN
    # from ->> tabella di sinistra
    select l.id, l.titolo, l.editore_id, e.id, e.nome
    from libro l
    left join editore e on e.id= l.editore_id;

    ## RIGHT JOIN
    # from ->> tabella di destra
    select l.id, l.titolo, l.editore_id, e.id, e.nome
    from libro l
    right join editore e on e.id= l.editore_id;

    # right join -> anche editori che non hanno libri
    # non ci sono problemi di integrità
    select l.titolo Titolo, e.nome 'Edito da' 
    from libro l 
    right join editore e
    on e.id=l.editore_id
    order by Titolo;

    # left join sarà == ad inner join
    # non ci sono libri con editore null -> non ci sono problemi di integrità dei dati


    # libro ->> editore null
    select l.id, l.titolo, l.editore_id, e.id, e.nome
    from libro l
    left join editore e on e.id= l.editore_id
    where l.editore_id is null;

    # editore ->> senza libri a catalogo
    select l.id, l.titolo, l.editore_id, e.id, e.nome
    from libro l
    right join editore e on e.id= l.editore_id
    where l.editore_id is null;

    # UNION ->> JOIN
    select l.id, l.titolo, l.editore_id, e.id, e.nome
    from libro l
    left join editore e on e.id= l.editore_id
    where l.editore_id is null
    UNION
    select l.id, l.titolo, l.editore_id, e.id, e.nome
    from libro l
    right join editore e on e.id= l.editore_id;

    #-------------------------------
    # SELF JOIN
    ## referenzia se stessa, grazie agli alias
    select i.nome, i.cognome, r.cognome
    from impiegato i, impiegato r 
    where i.rif_to = i.id 
    order by ruolo ;


    #-------------------------------
    # Integrità referenziale
    ## FOREIGN KEY CONSTRAINTS
    ## CASCADE, SET NULL, NO ACION o RESTRICT (sinonimi)

    # editore_id ->> deve avere indicizzazione 
    create table libro(
    ....
    INDEX editore_KEY(editore_id),
    CONSTRAINT fk_libro_editore
    FOREIGN KEY(editore_id) REFERENCES editore(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
    );

    # se cancello tupla, non cancello editore
    alter table libro 
    add constraint fk_libro_editore
        foreign key(editore_id)
        references editore(id)
            on delete no action
            on update no action;

    # ->>  Cannot add or update a child row: a foreign key constraint 
    # fails (`generation`.`#sql-20b4_8`, CONSTRAINT `fk_libro_editore` 
    # FOREIGN KEY (`editore_id`) REFERENCES `editore` (`id`) 
    # ON DELETE NO ACTION ON UPDATE NO ACTION)
    ##
    # ->> integrità del dato ->> ci sono degli editore_id che non sono presenti su editore!

    # mysql non ha FULL OUTER JOIN ->> usare UNION
    select l.id,l.titolo,l.editore_id,e.nome from libro l 
    LEFT join editore e on l.editore_id=e.id
    UNION 
    select l.id,l.titolo,l.editore_id,e.nome from libro l 
    RIGHT join editore e on l.editore_id=e.id
    ;

    update libro set editore_id=3 where editore_id=184 or editore_id=2;

    # provare a cancellare einaudi
    delete from editore where id=3;
    # ->> Cannot delete or update a parent row: a foreign key constraint 
    # fails (`generation`.`libro`, CONSTRAINT `fk_libro_editore` FOREIGN KEY (`editore_id`) 
    # REFERENCES `editore` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION)

    # fk ->> set null
    alter table libro drop foreign key fk_libro_editore;

    # se imposto editore_id NOT null ->> errore creazione foreign key
    alter table libro modify editore_id INT NOT NULL;

    # editore_id ->> null
    alter table libro modify editore_id INT NULL;

    alter table libro 
    add constraint fk_libro_editore
        foreign key(editore_id)
        references editore(id)
            on delete set null
            on update set null;

    # editore_id ->> diventano null automaticamente
    delete from editore where id=10;
    select * from libro where editore_id IS null;

    insert into editore(nome) value('Bompiani');
    update libro set editore_id=12 where editore_id is null;

    # fk ->> CASCADE
    alter table libro drop foreign key fk_libro_editore;

    alter table libro 
    add constraint fk_libro_editore
        foreign key(editore_id)
        references editore(id)
            on delete cascade
            on update cascade;

    delete from editore where id=1;
    select * from libro; # ->> tutti ediotre_id=1 sono stati cancellati

    # fk tabella autore_libro
    alter table autore_libro
    add constraint fk_al_libro
        foreign key(libro_id) references libro(id)
            on delete no action
            on update no action;

    alter table autore_libro 
    add constraint fk_al_autore
        foreign key(autore_id) references autore(id)
            on delete no action
            on update no action;

    # ->> test
    select l.id,l.titolo,al.id,al.libro_id from libro l left join autore_libro al  on  l.id=al.libro_id; 
    delete from libro where id=1; # errore ->> foreign key constraint

    # Visualizare Foreign Keys
    show create table libro\G

    # elenco completo fk ->> vista nel db information_schema
    SELECT TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME,REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME
    FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE 
    WHERE TABLE_SCHEMA='generation'
    ## AND TABLE_NAME='nome_tabella'
    AND referenced_column_name IS NOT NULL;

    # Disable fk
    SET FOREIGN_KEY_CHECKS=0;

    # Enable fk 
    SET FOREIGN_KEY_CHECKS=1;

    # Views
    # Create view ->> Semplice
    create or replace view nome_vista as 
    select * from bla-bla where ...

    # Rename view
    rename table nome_vista to nuovo_nome;

    Create or Replace VIEW studente_v 
    as select nome, cognome, genere, citta, data_nascita, email from studente;

    show create table studente_v\G  

    # table type ->> view
    select table_name, table_type from information_schema.tables 
    where table_Schema='generation' order by table_name;

    # insert ->> vista
    # vista semplice aggiornabile
    insert into studente_v(nome,cognome,genere,citta,data_nascita,email)
    value('albero','sordi','m','novara','1937-12-01','albsordi@gmail.com');


    # Drop View
    drop view studente_v;

    # View ->> Complessa
    # ->> non si possono fare insert
    # View NON aggiornabile se ha ->> Distinct,  Avg...,  Union/join
    CREATE OR REPLACE VIEW libro_tot_v AS 
    SELECT l.titolo,e.nome AS Editore, 
    CONCAT(a.cognome,' ',a.nome)  AS Autore, 
    ROUND(l.prezzo*1.22,2) AS Prezzo
    FROM libro l
    JOIN editore e ON l.editore_id=e.id
    JOIN autore_libro la ON l.id=la.libro_id
    JOIN autore a ON a.id=la.autore_id
    ORDER BY titolo;

    # view ->> With Check Option
    # view semplice ->> con Vincolo
    CREATE OR REPLACE VIEW studente_v2 AS
    SELECT nome, cognome, email, provincia
    FROM studente
    WHERE provincia='to'
    WITH CHECK OPTION;

    # ->> Check Option Failed
    insert into studente_v2(nome,cognome,email,provincia)
    value('albero','sordi','albsordi@gmail.com','CN');
    # ho accesso solo ai dati con provincia 'to'

    # Temp Table
    # Session ->> disappears on exit 
    # ->> not visible with show tables
    create TEMPORARY table studente_tmp as 
    SELECT nome, cognome, email, provincia
    FROM studente2;

    drop temporary table studente_t; # or exit


